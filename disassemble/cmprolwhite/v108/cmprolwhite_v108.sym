# Cooler Master MasterKeys Pro L White V1.08.00

[data]

3200 : vectors .word

[code]

*   +4 : reset
*   +4 : nmi
*   +4 : hard_fault
*  +20 : svccall_intr
*   +C : pendsv_intr
*   +4 : systick_intr
*   +4
*   +4
*   +4
*   +4
*   +4
*   +4
*   +4
*   +4
*   +4
*   +8
*   +4
*   +4
*   +4
*   +4
*   +C : bftm0_intr
*   +4 : bftm1_intr
*   +4
*   +4
*   +4
*   +4
*   +4
*   +4
*   +4
*   +4
*   +4
*   +4
*   +4 : usb_intr
*   +4
*   +4
*  +1C
*   +4
*   +4

32d6: generic_intr

# void entry(void)
32e4: entry
# void start_main(void)
32ec: start_main
# int32_t unsigned_int_div(uint32_t dividend, uint32_t divisor)
#   returns -1 if dividing by 0
32f8: unsigned_int_div
# int32_t signed_int_div(int32_t dividend, int32_t divisor)
#   returns 1 if dividing negative number by 0
#   returns -1 if dividing positive number by 0
3324: signed_int_div
334c: rand
335e: srand
# void memcpy(void *dst, void *src, size_t len)
3370: memcpy
# void * _memset(void *ptr, size_t len, uint8_t value)
3394: _memset
# void * _memzero(void *ptr, size_t len)
33a2: _memzero
# void * memset(void *ptr, uint8_t value, size_t len)
33a6: memset
# int memcmp(void *src1, void *src2, size_t len)
33b8: memcmp
33e8: sram_init
# afio_set_pin_mux(int exti_num, int port)
3464: afio_set_pin_mux
# void bftm_reset_compare_match_intr_flag(uint32_t *bftm_base)
35c0: bftm_reset_compare_match_intr_flag
# void afio_set_pin_config(int port_x, int pin_n, int function)
35fc: afio_set_pin_config
# void sleep(int n)
3624: sleep
362c
# void set_peripheral_clock_control(uint32_t AHBCCR, APBCCR0, APBCCR1, int set)
#   if set != 0, then set registers to given arg1, arg2, and arg3;
#   otherwise clear them
3714: set_peripheral_clock_control
3986
3a26
3a4c
3aa8
# uint8_t spi_flash_cmd_read_status_register(void)
3b18: spi_flash_cmd_read_status_register
# int spi_init(void)
3b3c: spi_init
# uint32_t spi_flash_read_wip(void)
3bb4: spi_flash_read_wip
# void spi_flash_cmd_sector_erase(uint32_t sectorAddr)
3bc0: spi_flash_cmd_sector_erase
3bf8: unused_3bf8
# int spi_gpio_init(void)
3c04: spi_gpio_init
# void spi_flash_pin_config_init(void)
3c84: spi_flash_pin_config_init
# void spi_flash_cmd_page_program(uint8_t *src, uint32_t pageAddr, size_t len)
3cc4: spi_flash_cmd_page_program
# void spi_flash_cmd_write_status_register(uint8_t value)
3d04: spi_flash_cmd_write_status_register
# int spi_flash_program_page(uint8_t *src, uint32_t pageAddr, size_t len)
3d2c: spi_flash_program_page
# void spi_flash_cmd_deep_power_down(void)
3d50: spi_flash_cmd_deep_power_down
# void spi_xfer(uint8_t *src, uint8_t *dst, size_t len)
3db0: spi_xfer
# void spi_flash_cmd_read_data(uint8_t *dst, uint8_t addr, size_t len)
3d78: spi_flash_cmd_read_data
# int spi_flash_erase_sector(uint8_t sectorAddr)
#   returns 0 on success
#   returns >0 on error
3e20: spi_flash_erase_sector
# void spi_flash_cmd_release_sleep(void)
3e4c: spi_flash_cmd_release_sleep
# int spi_flash_program_sector(uint8_t *src, uint32_t sectorAddr, size_t len)
3e74: spi_flash_program_sector
# void spi_flash_cmd_write_enable(void)
3eec: spi_flash_cmd_write_enable
# int spi_flash_set_status_register(uint32_t value)
3f0c: spi_flash_set_status_register
# void gpio_set_pin_direction(uint32_t *gpio_base, uint32_t pin, int out)
3f32: gpio_set_pin_direction
# void gpio_set_pin_drive_current(uint32_t *gpio_base, uint32_t pin, int eight_mA)
3f42: gpio_set_pin_drive_current
# void gpio_set_pin_input_enable(uint32_t *gpio_base, uint32_t pin, int enable)
3f72: gpio_set_pin_input_enable
# void gpio_set_pin_open_drain(uint32_t *gpio_base, uint32_t pin, int open_drain)
3f82: gpio_set_pin_open_drain
# void gpio_set_pin_pull_up_down(uint32_t *gpio_base, uint32_t pin, int pull_down)
3f92: gpio_set_pin_pull_up_down
# void gpio_set_reset_pin(uint32_t *gpio_base, uint32_t value, int SRR)
#   if SRR is != 0, then write to set/reset register, otherwise write to reset register
3fbc: gpio_set_reset_pin
529c
52b8
5370
53c8
53e4
53f4
5404
54a0
54cc
5550
55dc
55f4
5634
5754
5780
579c
57b8
57ec
5808
5824
5878
5888
5904
5928
5938
5948
5958
59a0
5a00
5a4c
5b04
5b58
5bbc
5c08
5c98
# void setup_intr_priority(void)
5d7c: setup_intr_priority
# void nvic_set_intr_priority(uint32_t intr_num, uint32_t priority)
5db4: nvic_set_intr_priority
# void nvic_set_vtor(uint32_t table_base, uint32_t table_offset)
#   table_base is either 0 (for code) or 0x20000000 (for RAM)
5df8: nvic_set_vtor
# int spi_flash_init(void)
5e0c: spi_flash_init
# void reset_peripherals(uint32_t AHBPRSTR, uint32_t APBPRSTR0, uint32_t APBPRSTR1, int set)
#   if set != 0, then set registers from given arg1, arg2, and arg3;
#   otherwise clear them
63a8: reset_peripherals
# void spi_enable(uint32_t *spi_base, int enable)
6a2c: spi_enable
# void spi_config(uint32_t *spi_base, struct spi_config_t *config)
#   struct spi_config_t {
#       uint32_t MODE_SEL; // either 0 for slave or 0x4000 for master
#       uint32_t FIFO_EN; // either 0x400 to enable fifo and 0 to disable
#       uint32_t SPICR1_unk1;
#       uint32_t DFL; // 4-bit value
#       uint32_t SPICR1_unk2;
#       uint32_t CPOL; // either 0 or 0x400
#       uint32_t CPHA; // either 0 or 1
#       uint32_t SPICR1_unk3;
#       uint32_t RX_FIFO_TRIGGER_LEVEL_SEL; // 4-bit value
#       uint32_t TX_FIFO_TRIGGER_LEVEL_SEL; // 4-bit value
#       uint32_t PRESCALER; // PRESCALER = f_pclk/(2*f_sck)
#   };
6a40: spi_config
# void spi_slave_select_output_enable(uint32_t *spi_base, int enable)
6a88: spi_slave_select_output_enable
# int spi_flash_set_check_wel(int op)
#   op == 0 : return 1 if WEL is set and 0 otherwise
#   op == 1 : unset WEL (and return 0)
#   op == 2 : set WEL (and return 1)
6a9a: spi_flash_set_check_wel
# void usb_entry(uint32_t addr) // TODO: understand struct at addr
76c0: usb_entry
# void usb_set_intr_flags(uint32_t value)
7850: usb_set_intr_flags
# void usb_reset(void)
7900: usb_reset
# void usb_ep_set_cfgr_ier(uint32_t ep_num, struct *usbep_config_t)
#   struct usbep_config_t {
#       uint32_t unk1;
#       uint32_t EPCFGR;
#       uint32_t EPIER;
#       ...  // unsure of size
#   };
79be: usb_ep_set_cfgr_ier
# void usb_ep_toggle_onak_odata_idata(uint32_t *epcsr_base)
7a4a: usb_ep_toggle_onak_odata_idata
# void usb_enable_ier(int enable)
7ac0: usb_enable_ier
# uint32_t usb_get_intr_flags(void)
7af0: usb_get_intr_flags
# void usb_set_lpmode_pdwn(void)
7b08: usb_set_lpmode_pdwn
# void usb_set_csr(void)
7b18: usb_set_csr
# void wdt_reload_timer(void)
7cac: wdt_reload_timer
# void spi_flash_write_sector(uint8_t *src, uint32_t sectorAddr, size_t len)
7cdc: spi_flash_write_sector
7fc0
7fc6
7fcc
7fd2
7fde
89b4: unused_89b4
8ac8
8bc0
8bcc
# uint32_t usb_compute_epcsr_addr(uint32_t ep_num)
8f08: usb_compute_epcsr_addr
# void copy_words(uint32_t *src, uint32_t *dst, size_t len)
#   len must be a multiple of 4.
#   In other words, src and dst must be aligned to 32-bits.
8fe6: copy_words
8ff4
8ff6
# void main(void)
9004: main

[data]

# Force data on some "code" that isn't code

3404!
3408!

348c: AFIO_BASE_348c
3524: BFTM0_BASE_3524
35b0: BFTM1_BASE_35b0
35b8: GPIOA_BASE_35b8
3620: AFIO.GPACFGLR_3620
36dc: CKCU_RSTCU_BASE_36dc
36f0: CKCU.HSICR_36f0
3710: CKCU.HSICR_3710
3738: CKCU.HSICR_3738
388c: SRAM.SPI_DATA_0_164_388c
36d8: GPIOA_BASE_36d8
3b38: GPIOB_BASE_3b38
3ba8: SRAM.INIT_STAGE_3ba8
3bac: SPI1_BASE_3bac
3bb0: GPIOB_BASE_3bb0
3bec: GPIOB_BASE_3bec
3c3c: SRAM.INIT_STAGE_3c3c
3c40: GPIOB_BASE_3c40
3c80: GPIOB_BASE_3c80
3cc0: GPIOB_BASE_3cc0
3d00: GPIOB_BASE_3d00
3d28: GPIOB_BASE_3d28
3d74: GPIOB_BASE_3d74
38f0: SRAM.SPI_DATA_0_166_38f0
3918: SRAM.SPI_DATA_0_164_3918
3934: SRAM.SPI_DATA_0_164_3934
3964: SRAM.SPI_DATA_0_164_3964
3dac: GPIOB_BASE_3dac
3e1c: SPI1_BASE_3e1c
3e70: GPIOB_BASE_3e70
3f08: GPIOB_BASE_3f08
4910: SRAM.SPI_DATA_0_164_4910
4afc: SRAM.SPI_DATA_0_164_4afc
5178: SRAM.SPI_DATA_0_164_5178
5d30: BFTM0_BASE_5d30
5d34: NVIC.ICER_5d34
5df0: NVIC.CPUID_5df0
5df4: NVIC.IP0_5df4
5d78: BFTM0_BASE_5d78
5e04: vtor_offset_mask_5e04
5e08: NVIC.CPUID_5e08
6118: GPIOC_BASE_6118
6138: GPIOC_BASE_6138
6154: GPIOC_BASE_6154
61a8: CKCU_RSTCU_BASE_61a8
61ac: PWRCU.BAKSR_61ac
61b0: NVIC.CPUID_61b0
61f0: CKCU_RSTCU_BASE_61f0
61f4: PWRCU.BAKSR_61f4
61f8: NVIC.CPUID_61f8
6214: NVIC.CPUID_6214
6308: FMC.MDID_6308
6360: NVIC.ICER_6360
636c: NVIC.VECTKEY_SYSRESETREQ_636c
6370: NVIC.CPUID_6370
63cc: RSTCU.GRSR_63cc
67a0: BFTM1_BASE_67a0
67a4: GPIOC_BASE_67a4
67a8: GPIOA_BASE_67a8
67ac: GPIOB_BASE_67ac
682c: BFTM1_BASE_682c
6830: NVIC.ICER_6830
6834: GPTM1_BASE_6834
6838: GPIOC_BASE_6838
6840: GPIOA_BASE_6840
690c: GPIOC_BASE_690c
6910: GPIOA_BASE_6910
6920: GPTM1_BASE_6920
6924: BFTM1_BASE_6924
6928: NVIC.ISER_6928
6a14: GPIOA_BASE_6a14
6a1c: GPIOC_BASE_6a1c
6b58: CKCU.LPCR_6b58
6b5c: CKCU_RSTCU_BASE_6b5c
6b60: PWRCU.BAKSR_6b60
6b64: RTC_PWRCU_BASE_6b64
6b6c: WDT_BASE_6b6c
6b70: FMC.CFCR_6b70
6c38: MCTM_BASE_6c38
6c78: MCTM_BASE_6c78
6d1c: NVIC.ICER_6d1c
71c8: SRAM.SPI_DATA_0_164_71c8
748c: SRAM.SPI_DATA_0_164_748c
7858: USB_BASE_7858
78c4: NVIC.ISER_78c4
78e4: USB_BASE_78e4
78fc: USB_BASE_78fc
7950: EP_SRAM_BASE_7950
7974: EP_SRAM_BASE_7974
7acc: USB_BASE_7acc
7afc: USB_BASE_7afc
7b14: USB_BASE_7b14
7b24: USB_BASE_7b24
7b94: USB_BASE_7b94
7c48: EP_SRAM_BASE_7c48
7c58: USB_BASE_7c58
7c6c: USB_BASE_7c6c
7c7c: USB_BASE_7c7c
7c98: RSTCU.GRSR_7c98
7ca0: WDT_BASE_7ca0
7ca8: PxLOCKR_LOCK_7ca8
7cb4: PxLOCKR_LOCK_7cb4
7cb8: WDT_BASE_7cb8
7cd4: SRAM.SPI_DATA_0_164_7cd4
8828: GPIOC_BASE_8828
882C: GPIOA_BASE_882C
8830: GPIOB_BASE_8830
8884: GPTM1_BASE_8884
88b8: GPIOA_BASE_88b8
88ec: GPIOA_BASE_88ec
88f0: GPIOB_BASE_88f0
8924: GPIOC_BASE_8924
8928: GPIOA_BASE_8928
8ac0: USB.USBEP2IER_8ac0
8f14: USB.USBEP0CSR_8f14
8fbc: EXTI.EXTICR_8fbc
8fc4: USB_BASE_8fc4
940d: gpio_map_1 .word 16
945d: gpio_map_2 .word 32
94e8: gpio_map_3 .word 16
97a8: usb_report1_desc
97cc: usb_report2_desc
9854: usb_report0_desc
9894: usb_config_desc
  +9: usb_interface0_desc
  +9: usb_hid0_desc
  +9: usb_ep1_desc
  +7: usb_interface1_desc
  +9: usb_hid1_desc
  +9: usb_ep3_desc
  +7: usb_ep4_desc
  +7: usb_interface2_desc
  +9: usb_hid2_desc
  +9: usb_ep2_desc
98f0: usb_device_desc
9910: usb_str0_desc
9914: usb_str2_desc
9954: usb_str1_desc

* 3404
* 3408
* 9e28

[annote]

940d: GPIO C, pin 4
  +8: GPIO A, pin 5
  +8: GPIO A, pin 6
  +8: GPIO A, pin 7
  +8: GPIO C, pin 8
  +8: GPIO B, pin 10
  +8: GPIO B, pin 11
  +8: GPIO B, pin 12

945d: GPIO D, pin 1
  +8: GPIO C, pin 1
  +8: GPIO D, pin 0
  +8: GPIO B, pin 8
  +8: GPIO A, pin 11
  +8: GPIO A, pin 0
  +8: GPIO A, pin 1
  +8: GPIO A, pin 2
  +8: GPIO A, pin 8
  +8: GPIO A, pin 4
  +8: GPIO C, pin 5
  +8: GPIO C, pin 9
  +8: GPIO C, pin 14
  +8: GPIO A, pin 10
  +8: GPIO B, pin 1
  +8: GPIO A, pin 3

94e8: GPIO C, pin 15
  +8: GPIO C, pin 14
  +8: GPIO B, pin 5
  +8: GPIO B, pin 4
  +8: GPIO B, pin 3
  +8: GPIO B, pin 2
  +8: GPIO D, pin 3
  +8: GPIO D, pin 2

97a8: Usage Page (Vendor)
  +3: Usage (Vendor)
  +2: Collection (Application)
  +2: - Usage (Vendor)
  +2: - Logical Minimum (0x00)
  +2: - Logical Maximum (0x00ff)
  +3: - Report Size (0x08)
  +2: - Report Count (0x40)
  +2: - Input (Data,Var,Abs)
  +2: - Usage (Vendor)
  +2: - Logical Minimum (0x00)
  +2: - Logical Maximum (0x00ff)
  +3: - Report Size (0x08)
  +2: - Report Count (0x40)
  +2: - Output (Data,Var,Abs)
  +2: - End Collection

97cc: Usage Page (Generic Desktop Controls)
  +2: Usage (System Control)
  +2: Collection (Application)
  +2: - Report ID (0x01)
  +2: - Usage Minimum (0x81)
  +2: - Usage Maximum (0x83)
  +2: - Logical Minimum (0x00)
  +2: - Logical Maximum (0x01)
  +2: - Report Count (0x03)
  +2: - Report Size (0x01)
  +2: - Input (Data,Var,Abs,No Wrap,Linear,Preferred State,No Null Position)
  +2: - Report Count (0x01)
  +2: - Report Size (0x05)
  +2: - Input (Const,Array,Abs)
  +2: - End Collection
  +1: Usage Page (Consumer)
  +2: Usage (Consumer Control)
  +2: Collection
  +2: - Report ID (0x02)
  +2: - Logicial Minimum (0x00)
  +2: - Logical Maximum (0x01)
  +2: - Report Count (0x12)
  +2: - Report Size (0x01)
  +2: - Usage (Instance 33537)
  +3: - Usage (Instance 35329)
  +3: - Usage (Instance 37377)
  +3: - Usage (Instance 37889)
  +3: - Usage (Play/Pause)
  +2: - Usage (Stop)
  +2: - Usage (Scan Previous Track)
  +2: - Usage (Scan Next Track)
  +2: - Usage (Mute)
  +2: - Usage (Volume Decrement)
  +2: - Usage (Volume Increment)
  +2: - Usage (Instance 8450)
  +3: - Usage (Instance 8962)
  +3: - Usage (Instance 9218)
  +3: - Usage (Instance 9474)
  +3: - Usage (Instance 9730)
  +3: - Usage (Instance 9986)
  +3: - Usage (Instance 10754)
  +3: - Input (Data,Var,Abs)
  +2: - Report Count (0x01)
  +2: - Report Size (0x0e)
  +2: - Input (Const,Array,Abs)
  +2: - End Collection
  +1: Usage Page (Generic Desktop Controls)
  +2: Usage (Keyboard)
  +2: Collection (Application)
  +2: - Report ID (0x04)
  +2: - Usage Page (Keyboard/Keypad)
  +2: - Report Count (0x01)
  +2: - Report Size (0x08)
  +2: - Input (Const,Var,Abs)
  +2: - Report Count (0xe8)
  +2: - Report Size (0x01)
  +2: - Logical Minimum (0x00)
  +2: - Logical Maximum (0x01)
  +2: - Usage Page (Keyboard/Keypad)
  +2: - Usage Minimum (0x00)
  +2: - Usage Maximum (0xe7)
  +2: - Input (Data,Array,Abs)
  +2: - End Collection

9854: Usage Page (Generic Desktop Controls)
  +2: Usage (Keyboard)
  +2: Collection (Application)
  +2: - Usage Page (Keyboard/Keypad)
  +2: - Usage Minimum (0xe0)
  +2: - Usage Maximum (0xe7)
  +2: - Logical Minimum (0x00)
  +2: - Logical Maximum (0x01)
  +2: - Report Size (0x01)
  +2: - Report Count (0x08)
  +2: - Input (Data,Var,Abs)
  +2: - Report Count (0x01)
  +2: - Report Size (0x08)
  +2: - Input (Const,Var,Abs)
  +2: - Report Count (0x03)
  +2: - Report Size (0x01)
  +2: - Usage Page (LED)
  +2: - Usage Minimum (0x01)
  +2: - Usage Maximum (0x03)
  +2: - Output (Data,Var,Abs)
  +2: - Report Count (0x01)
  +2: - Report Size (0x05)
  +2: - Output (Const,Var,Abs)
  +2: - Report Count (0x06)
  +2: - Report Size (0x08)
  +2: - Logical Minimum (0x00)
  +3: - Logical Maximum (0x00a4)
  +2: - Usage Page (Keyboard/Keypad)
  +2: - Usage Minimum (0x00)
  +2: - Usage Maximum (0xa4)
  +2: - Input (Data,Array,Abs)
  +2: - End Collection

9894: bLength (0x09)
  +1: bDescriptorType (CONFIGURATION 0x02)
  +2: wTotalLength (0x005b)
  +1: bNumInterfaces (0x03)
  +1: bConfigurationValue (0x01)
  +1: iConfiguration (0x00)
  +1: bmAttributes (NOT SELF-POWERED REMOTE-WAKEUP 0xa0)
  +1: bMaxPower (50mA 0x32)

989d: bLength (0x09)
  +1: bDescriptorType (INTERFACE 0x04)
  +1: bInterfaceNumber (0x00)
  +1: bAlternateSetting (0x00)
  +1: bNumEndpoints (0x01)
  +1: bInterfaceClass (HID 0x03)
  +1: bInterfaceSubClass (Boot Interface 0x01)
  +1: bInterfaceProtocol (Keyboard 0x01)
  +1: iInterface (0x00)

98a6: bLength (0x09)
  +1: bDescriptorType (HID 0x21)
  +1: bcdHID (0x0111)
  +2: bCountryCode (Not Supported 0x00)
  +1: bNumDescriptors (0x01)
  +1: bDescriptorType (HID Report 0x22)
  +1: wDescriptorLength (0x0040)

98af: bLength (0x07)
  +1: bDescriptorType (ENDPOINT 0x05)
  +1: bEndpointAddress (Direction:IN,Endpoint:1 0x81)
  +1: bmAttributes (TransferType:Interrupt-Transfer 0x03)
  +1: wMaxPacketSize (0x0008)
  +2: bInterval (0x01)

98b6: bLength (0x09)
  +1: bDescriptorType (INTERFACE 0x04)
  +1: bInterfaceNumber (0x01)
  +1: bAlternateSetting (0x00)
  +1: bNumEndpoints (0x02)
  +1: bInterfaceClass (HID 0x03)
  +1: bInterfaceSubClass (No Subclass 0x00)
  +1: bInterfaceProtocol (0x00)
  +1: iInterface (0x00)

98bf: bLength (0x09)
  +1: bDescriptorType (HID 0x21)
  +1: bcdHID (0x0111)
  +2: bCountryCode (Not Supported 0x00)
  +1: bNumDescriptors (0x01)
  +1: bDescriptorType (HID Report 0x22)
  +1: wDescriptorLength (0x0022)

98c8: bLength (0x07)
  +1: bDescriptorType (ENDPOINT 0x05)
  +1: bEndpointAddress (Direction:IN,Endpoint:3 0x83)
  +1: bmAttributes (0x03)
  +1: wMaxPacketSize (0x0040)
  +2: bInterval (0x01)

98cf: bLength (0x07)
  +1: bDescriptorType (ENDPOINT 0x05)
  +1: bEndpointAddress (Direction:OUT,Endpoint:4 0x04)
  +1: bmAttributes 0x03
  +1: wMaxPacketSize (0x0040)
  +2: bInterval (0x01)

98d6: bLength (0x09)
  +1: bDescriptorType (INTERFACE 0x04)
  +1: bInterfaceNumber (0x02)
  +1: bAlternateSetting (0x00)
  +1: bNumEndpoints (0x01)
  +1: bInterfaceClass (HID 0x03)
  +1: bInterfaceSubClass (No Subclass 0x00)
  +1: bInterfaceProtocol (0x00)
  +1: iInterface (0x00)

98df: bLength (0x09)
  +1: bDescriptorType (HID 0x21)
  +1: bcdHID (0x0111)
  +2: bCountryCode (Not Supported 0x00)
  +1: bNumDescriptors (0x01)
  +1: bDescriptorType (HID Report 0x22)
  +1: wDescriptorLength (0x0086)

98e8: bLength (0x07)
  +1: bDescriptorType (ENDPOINT 0x05)
  +1: bEndpointAddress (Direction:IN,Endpoint:2 0x82)
  +1: bmAttributes (0x03)
  +1: wMaxPacketSize (0x0040)
  +2: bInterval (0x01)

98f0: bLength (0x12)
  +1: bDescriptorType (DEVICE 0x01)
  +1: bcdUSB (0x0110)
  +2: bDeviceClass (Device 0x00)
  +1: bDeviceSubClass (0x00)
  +1: bDeviceProtocol (0x00)
  +1: bMaxPacketSize0 (0x40)
  +2: idVendor (0x2516)
  +2: idProduct (0x0047)
  +2: bcdDevice (0x1108)
  +1: iManufacturer (0x01)
  +1: iProduct (0x02)
  +1: iSerialNumber (0x00)
  +1: bNumConfigurations (0x01)

9910: bLength (0x04)
  +1: bDescriptorType (STRING 0x03)
  +1: wLANGID (English (United States) 0x0409)

9914: bLength (0x3c)
  +1: bDescriptorType (STRING 0x03)
  +1: bString (Cooler Master Technology Inc.)

9954: bLength (0x2e)
  +1: bDescriptionType (STRING 0x03)
  +1: bString (MasterKeys Pro L White)
